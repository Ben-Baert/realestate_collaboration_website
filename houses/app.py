from flask import Flask, has_request_context, make_response, request
from celery import Celery, Task
from flask_wtf.csrf import CsrfProtect
from flask.ext.bcrypt import Bcrypt
from flask.ext.login import LoginManager
from flask.ext.bootstrap import Bootstrap
from flask.ext.mail import Mail, Message
from flask_googlemaps import GoogleMaps
from flask_pagedown import PageDown
from flaskext.markdown import Markdown
from jinja2.utils import Markup
from .utils import ListConverter
import operator



app = Flask(__name__)
app.config.from_object('config')

app.url_map.converters['list'] = ListConverter

login_manager = LoginManager()
login_manager.init_app(app)

CsrfProtect(app)

bcrypt = Bcrypt(app)

Bootstrap(app)

mail = Mail(app)

GoogleMaps(app)

pagedown = PageDown(app)

Markdown(app)

celery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])
celery.conf.update(app.config)

class RequestContextTask(Task):
    """Base class for tasks that originate from Flask request handlers
    and carry over most of the request context data.
    This has an advantage of being able to access all the usual information
    that the HTTP request has and use them within the task. Pontential
    use cases include e.g. formatting URLs for external use in emails sent
    by tasks.
    """

    abstract = True

    #: Name of the additional parameter passed to tasks
    #: that contains information about the original Flask request context.
    CONTEXT_ARG_NAME = '_flask_request_context'
    
    def __call__(self, *args, **kwargs):
        """Execute task code with given arguments."""
        call = lambda: super(RequestContextTask, self).__call__(*args, **kwargs)

        context = kwargs.pop(self.CONTEXT_ARG_NAME, None)
        if context is None or has_request_context():
            return call()

        with app.test_request_context(**context):
            result = call()

            # process a fake "Response" so that
            # ``@after_request`` hooks are executed
            app.process_response(make_response(result or ''))

        return result

    def apply_async(self, args=None, kwargs=None, **rest):
        if rest.pop('with_request_context', True):
            self._include_request_context(kwargs)
        return super(RequestContextTask, self).apply_async(args, kwargs, **rest)

    def apply(self, args=None, kwargs=None, **rest):
        if rest.pop('with_request_context', True):
            self._include_request_context(kwargs)
        return super(RequestContextTask, self).apply(args, kwargs, **rest)

    def retry(self, args=None, kwargs=None, **rest):
        if rest.pop('with_request_context', True):
            self._include_request_context(kwargs)
        return super(RequestContextTask, self).retry(args, kwargs, **rest)

    def _include_request_context(self, kwargs):
        """Includes all the information about current Flask request context
        as an additional argument to the task.
        """

        if not has_request_context():
            return

        # keys correspond to arguments of :meth:`Flask.test_request_context`
        context = {
            'path': request.path,
            'base_url': request.url_root,
            'method': request.method,
            'headers': dict(request.headers),
        }
        if '?' in request.url:
            context['query_string'] = request.url[(request.url.find('?') + 1):]

        kwargs[self.CONTEXT_ARG_NAME] = context

celery.Task = RequestContextTask

@login_manager.user_loader
def load_user(_id):
    return User.get(_id=_id)
"""

from .models import BaseModel, database, UserNotAvailableError
# This hook ensures that a connection is opened to handle any queries
# generated by the request.
@app.before_request
def _db_connect():
    database.connect()

# This hook ensures that the connection is closed when we've finished
# processing the request.
@app.teardown_request
def _db_close(exc):
    if not database.is_closed():
        database.close()


@app.before_first_request
def setup_database():
    for cls in BaseModel.tables():
        #  cls.drop_table(fail_silently=True)
        cls.create_table(fail_silently=True)
    try:
        User.get_or_create(username="Ben", password="degeleis2jaaroud")
        User.get_or_create(username="Melissa", password="degeleis2jaaroud")
    except UserNotAvailableError:
        pass


@app.before_first_request
def setup_builtin_criteria():
    from .criteria import criteria_list
    from .models import RealestateCriterion, Realestate, RealestateCriterionScore
    extra_criteria = [
    ('privacy', 'Privacy', False, 10, ['house', 'land'])]
    for short, name, dealbreaker, importance, applies_to in criteria_list:
        try:
            criterion = RealestateCriterion.get(short=short)
        except DoesNotExist:
            criterion = RealestateCriterion.create(
                             short=short,
                             name=name,
                             dealbreaker=dealbreaker,
                             importance=importance,
                             applies_to_house='house' in applies_to,
                             applies_to_land='land' in applies_to,
                             builtin=True)
        for realestate in Realestate.select():
            RealestateCriterionScore.get_or_create(realestate=realestate, criterion=criterion)

@app.before_first_request
def setup_information():
    from .models import RealestateInformationCategory
    INFORMATION = [
    ("year", "Year", "Bouwjaar", ['house']),
    ("cadastral_income", "Cadastral income", "Kadastraal Inkomen", ['house']),
    ("spatial_planning", "Spatial planning", "Ruimtelijke ordening", ['house']),
    ("epc", "EPC score", "EPC waarde", ['house']),
    ("heating", "Heating", "Type verwarming", ['house']),
    ("building", "Building", "Bebouwing", ['house'])]
    for short, name, realo_name, applies_to in INFORMATION:
        RealestateInformationCategory.get_or_create(_short=short, 
                                               _name=name,
                                               _realo_name=realo_name,
                                               applies_to_house='house' in applies_to,
                                               applies_to_land='land' in applies_to)
"""
@app.template_filter('information')
def informationfilter(s):
    return s or "?"

@app.template_filter('dealbreakerscore')
def dealbreakerscore(s):
    if s == 0:
        html = "X"
    elif s == 1:
        html = "OK"
    else:
        html = "?"
    return Markup(html)



@app.template_filter('price')
def price(s):
    return 'â‚¬{0:,}'.format(s)


@app.template_filter('area')
def area(s):
    return Markup('{0:,}m<sup>2</sup>'.format(s))


@app.template_filter('multisort')
def sort_multi(L, *operators): 
    return sorted(L, key=operator.attrgetter(*operators))

@app.template_filter('date')
def date(d):
    try:
        return d.strftime("%d/%m/%Y")
    except AttributeError:
        return "?"

from .controllers import *
